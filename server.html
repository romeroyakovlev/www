<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ii : сервер</title>
    <link rel="stylesheet" href="s/css/foundation.min.css" />
    <link rel="icon" type="image/png" href="s/favicon.png" />
    <script src="s/js/vendor/modernizr.js"></script>
  </head>

<body>

<div class="row">
    <div class="large-12 columns" align="right">
          <a class="tiny secondary button" href="index.html">главная</a>
          <a class="tiny secondary button" href="about.html">об</a>
          <a class="tiny secondary button" href="primen.html">применение</a>
          <a class="tiny secondary button" href="gate.html">гейты</a>
          <a class="tiny secondary button" href="php.html">php</a>
          <a class="tiny secondary button" href="pure.html">крайности</a>
          <a class="tiny  button" href="server.html">сервер</a>
          <a class="tiny secondary button" href="tech.html">технология</a>
    <a class="left tiny button alert" href="./">ii</a>
    </div>
</div>
  <div class="row">
    <div class="large-12 columns">

      <h3>Базовая реализация</h3>

      <hr />


<h3>Сайт</h3>

<p>
Официальный сервер - это ещё и простой, но симпатичный веб-сайт, помесь форума и твиттера с неограниченным числом эх,
подходящий для спокойных бесед спокойных сообществ.
Поэтому можно спокойно общаться через него, не задумываясь о каких-то обменах сообщениями и клиентах.
Но самое интересное начинается тогда, когда захочется обмениваться и клиента.</p>


<h3> плоское api /e /m </h3>

<p>Самая простая реализация, без /u/ и без приёма пойнтовых сообщений, выглядит так:</p>

<h4>Сервер (использует bottle.py):</h4>

<div class="panel">
<pre>
import bottle

@bottle.route('/m/<h:re:[a-zA-Z0-9]{20}>')
def msg(h):
    return open('msg/%s' % h).read()

@bottle.route('/e/<echo:re:[a-z0-9_.!-]{60}>.<year:int>')
def elist(echo,year):
    return open('echo/%s.%s' % h).read()

bottle.run(port=62220)
</pre>
</div>

<hr />

<h4>Клиент</h4>

<div class="panel">
<pre>
URL='http://51t.ru/'
ECHO='ii.test.2014 ii.about.2014 ii.dev.2014'

def getf(l):
    import urllib; print l; return urllib.urlopen(URL + l).read()

def get_echoarea(name):
    try: return open('echo/%s' % name).read().splitlines()
    except: return []

def savemsg(ea,h,s):
    open('msg/%s' % h,'w').write(s)
    open('echo/%s' % ea, 'a').write(h + '\n')

for ea in ECHO.split():
    newel = getf('e/%s' % ea).splitlines()
    myel = set(get_echoarea(ea))
    for h in newel:
        if h not in myel:
            s = getf('m/%s' % h)
            savemsg(ea,h,s)
</pre>
</div>


<p>В принципе, эта уже работоспособная система ii, которая позволяет синхронизироваться,
обмениваясь сообщениями, и быть неким транзитным узлом. Нет только пойнтовой отправки сообщений,
и работы с бандлами (чтобы качать сообщения не по одному), а всё остальное - присутствует. На всём
этом, на односторонней синхронизации и постоянном добавлении, и строится весь формат ii.</p>

<p>Более сложные структуры - только для большей скорости синхронизации с клиентами.</p>

<p>И отдельной строкой - пойнтовые письма, которые, собственно, и составляют таинство
создания сообщений (иначе просто меняться будет нечем).</p>


<h3>/u/</h3>

<p>Окончание URL сервера /u/ в настройках клиента указывает, что используется новая 
схема /u/ (universal), которая не так эффективна, но более, кхм, универсальна, по сравнению со 
старой схемой /z/ (которая может смело расшифровываться, как "занудная" или "заумная"), более
не поддерживаемой. Поэтому во всех адресах теперь должно быть написано СЕРВЕР/u/, и всё.</p>

<h3> обработчики /u/ </h3>

<p>/u/ - это запросы для обмена сообщениями, на которых и строится вся синхронизация.</p>

<p>В текущей версии вся синхронизация - односторонняя. Кто, как и с кем
будет сихнронизироваться - это всё обговаривается персонально. Но, в общем случае, две ноды просто собирают
друг у друга сообщения. Пойнты же, наоборот, проталкивают свои письма, которые нод делает полноценными
сообщениями сети, одобряя их (или не делает, не одобряя).</p>

<h4> /u/e/эха.номер/эха.номер/эха.номер </h4>

<p>Список сообщений из заданных эх, в формате:</p>

<pre>эха
msgid
msgid
msgid
эха
msgid</pre>
<br />
<p>Отличить эху от сообщения очень просто - в имени эхи есть точка, а в номере сообщения - нет.</p>


<h4>/u/m/msgid/msgid/msgid...</h4>

<p>бандл сообщений, в формате</p>

<pre>строка:код
строка:код</pre>
<br />
<p>где код - закодированное base64 сообщения (все серверы обязаны принимать как обычный, так и urlsafe-словарь, генерируются же бандлы в формате обычного base64)


<h4> GET /u/point/pauth/tmsg или POST /u/point</h4>

<p>Передаёт пользовательское сообщение ноду в виде запакованного текста base64 определённого формата 
(замечания те же, что и выше. кроме того, сообщение можно передать и через get-запрос, и вот там 
уже обязан быть base64_urlsafe)</p>


<h3>/u/push - push-ноды</h3>

<p>Кроме отправки данных, ноды могут (но не обязаны) реализовывать формат push, который принимает нодовые сообщения.
push - это бандл наоборот. если фетчинг скачивает бандлы, то push их проталкивает на другой узел (нововый или пойнтовый.)

<p>Ноды, которые поддерживают u/push, называются <b>push-ноды</b>.</p>

<p><em>Формат такой же, как и у бандлов, метод засылки - такой же, как и у point-пуша (собственно, в версии 0.1 
этот метод и назывался push, а нодовый пуш назывался jt. до революции была вообще такая путаница с терминами)</em></p>

<p>Сначала запрашивается список сообщений, которые уже есть в эхе, а затем через u/push загружаются недостающие.</p>

<p>В настоящее время существует очень простая реализация транзитной push-ноды на php</p>



    </div>
  </div>



  <!-- Footer -->

    <div class="row"><div class="large-12 columns">

        <hr />

        <div class="right">
          <a class="tiny secondary button" href="index.html">главная</a>
          <a class="tiny secondary button" href="about.html">об</a>
          <a class="tiny secondary button" href="primen.html">применение</a>
          <a class="tiny secondary button" href="gate.html">гейты</a>
          <a class="tiny secondary button" href="php.html">php</a>
          <a class="tiny secondary button" href="pure.html">крайности</a>
          <a class="tiny  button" href="server.html">сервер</a>
          <a class="tiny secondary button" href="tech.html">технология</a>
        </div>

    </div></div>





    <script src="s/js/vendor/jquery.js"></script>
    <script src="s/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
</body>
</html>
